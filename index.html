<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Day 1</title>
</head>

<body>
    <h1 style="text-align: center;">JS INTERVIEW QUESTIONS</h1>
    <h4>Q.1 Difference between “ == “ and “ === “ operators.</h4>
    <ul>
        <li>Double equals (==) is a comparison operator, which transforms the operands having the same type before
            comparison.</li>
        <li>So, when you compare string with a number, JavaScript converts any string to a number. An empty string is
            always converts to zero. A string with no numeric value is converts to NaN (Not a Number), which returns
            false.</li>
        <li>The == operator is an equality operator. It checks whether its two operands are the same or not by changing
            expression from one data type to others. You can use == operator in order to compare the identity of two
            operands even though, they are not of a similar type.</li>
    </ul>
    <pre>Example:
        var a = 10;
        document.getElementById("demonstration").innerHTML = (a == 20);
Output:   
        false
</pre>
    <ul>
        <li>=== (Triple equals) is a strict equality comparison operator in JavaScript, which returns false for the
            values which are not of a similar type. This operator performs type casting for equality. If we compare 2
            with “2” using ===, then it will return a false value.</li>
        <li>Strict equality === checks that two values are the same or not.</li>
        <li>If the variable values are of different types, then the values are considered as unequal.
            If the variable are of the same type, are not numeric, and have the same value, they are considered as
            equal.
            Lastly, If both variable values are numbers, they are considered equal if both are not NaN (Not a Number)
            and are the same value.</li>
    </ul>
    <pre>
  var x = 10;
  document.getElementById("demo").innerHTML = (x === "10");
  Output:
        false
    </pre>
    <h4>Q.2 what is the spread operator?</h4>
    <ul>
        <li>
            ES6 provides a new operator called spread operator that consists of three dots (...). The spread operator
            allows you to spread out elements of an iterable object such as an array, map, or set. For example:
        </li>
    </ul>
    <pre>
        const odd = [1, 3, 5];
        const combined = [2, 4, 6, ...odd];
        console.log(combined);

        Output:
                [2, 4, 6, 1, 3, 5]</pre>
    <ul>
        <li>In this example, the three dots ( ...) located in front of the odd array is the spread operator. The spread
            operator (...) unpacks the elements of the odd array.</li>
    </ul>
    <h4>Q.3 What are the differences between var, let and const?</h4>
    <ul>
        <li>In JavaScript, users can declare a variable using 3 keywords that are var, let, and const.</li>
    </ul>
    <h3>Var</h3>
    <ul>
        <li>The var is the oldest keyword to declare a variable in JavaScript. </li>
        <li>Scope: Global scoped or function scoped. The scope of the var keyword is the global or function scope. It
            means variables defined outside the function can be accessed globally, and variables defined inside a
            particular function can be accessed within the function. </li>
    </ul>
    <pre>
            var a = 10

            function f(){
                console.log(a)
            }

            f();
            console.log(a);

           <b>Output:</b> 
            10
            10  
    </pre>
    <h3>let</h3>
    <ul>
        <li>The let keyword is an improved version of the var keyword. </li>
        <li>Variables defined with let cannot be Redeclared.</li>
        <li>Variables defined with let must be Declared before use.</li>
        <li>Scope: block scoped: The scope of a let variable is only block scoped. It can’t be accessible outside the
            particular block ({block}). Let’s see the below example.</li>
    </ul>
    <pre>
            let a = 10;
            function f() {
                if (true) {
                    let b = 9

                    // It prints 9
                    console.log(b);
                }

                // It gives error as it
                // defined in if block
                console.log(b);
            }
            f()

            // It prints 10
            console.log(a)

           <b>Output:</b> 
            9
            ReferenceError: b is not defined          
    </pre>
    <h3>const</h3>
    <ul>
        <li>The const keyword has all the properties that are the same as the let keyword, except the user cannot update
            it.</li>
        <li>Scope: block scoped: When users declare a const variable, they need to initialize it, otherwise, it returns
            an error. The user cannot update the const variable once it is declared. </li>
        <li>Variables defined with const cannot be Redeclared.</li>
        <li>Variables defined with const must be Declared before use.</li>
    </ul>
    <pre>
        const a = 10;
        function f() {
        a = 9
        console.log(a)
    }
    f();

           <b>Output:</b> 
            a=9
            TypeError:Assignment to constant variable.
    </pre>
    <h4>Q.4 What is execution context</h4>
    <ul>
        <li>Execution context (EC) is defined as the environment in which the JavaScript code is executed. By
            environment, I mean the value of this , variables, objects, and functions JavaScript code has access to at a
            particular time.</li>
        <li>During the execution phase, the JavaScript engine executes the code line by line, assigns the values to
            variables, and executes the function calls.</li>
        <li>The concept of an execution context is used to describe how a code works inside. JavaScript execution
            context refers to the environment that allows JavaScript code to be executed.</li>
        <li>The execution context determines which code section has access to the code's functions, variables, and
            objects.</li>
    </ul>
    <h4>Q.5 What is meant by first class functions</h4>
    <ul>
        <li> A programming language is said to have First-class functions if functions in that language are treated like
            other variables. So the functions can be assigned to any other variable or passed as an argument or can be
            returned by another function. JavaScript treat function as a first-class-citizens. This means that functions
            are simply a value and are just another type of object.</li>
    </ul>
    <pre>
            Example:
                     const foo = () => {
                     console.log("foobar");
                     };
                    foo(); // Invoke it using the variable
                    // foobar  
    </pre>
    <ul>
        <li>We assigned an Anonymous Function in a Variable, then we used that variable to invoke the function by adding
            parentheses () at the end.</li>
    </ul>
    <h4>Q.6 What are closures? Give an example of closure</h4>
    <ul>
        <li>A closure is the combination of a function bundled together (enclosed) with references to its surrounding
            state (the lexical environment). In other words, a closure gives you access to an outer function's scope
            from an inner function. In JavaScript, closures are created every time a function is created, at function
            creation time.</li>
        <li>A closure is a function having access to the parent scope, even after the parent function has closed.</li>
    </ul>
    <pre>
        function show(){
            let a = 20;
            function innerfun(){
                let b =20;
                let c =a+b;
                console.log(c);
            }
            innerfun();
        }
       show();
    </pre>
    <h4>Q.7 Explain call(), apply() and, bind() methods. Give an example of call(), apply(), bind()</h4>
    <h3>Function Call():</h3>
    <ul>
        <li>With the call() method, you can write a method that can be used on different objects. </li>
        <li>The call() method is a predefined JavaScript method.
            It can be used to invoke (call) a method with an owner object as an argument (parameter).
            With call(), an object can use a method belonging to another object.
        </li>
    </ul>
    <pre>
        const person = {
            fullName: function() {
              return this.firstName + " " + this.lastName;
            }
          }
          const person1 = {
            firstName:"John",
            lastName: "Doe"
          }
          const person2 = {
            firstName:"Mary",
            lastName: "Doe"
          }
          
          // This will return "John Doe":
          person.fullName.call(person1);

          This example calls the fullName method of person, using it on person1:
    </pre>
    <h3>Function apply()</h3>
    <ul><li>With the apply() method, you can write a method that can be used on different objects.
    </li></ul>
</body>

</html>